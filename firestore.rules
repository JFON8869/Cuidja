/**
 * Core Philosophy: This ruleset implements a robust security model for the "Mercado Local Cuidja"
 * platform. It enforces strict user ownership for private data while enabling a public marketplace.
 * The core principle is that users have complete control over their own information and the
 * content they create, but limited or no access to the data of others.
 *
 * Data Structure: The data is organized into two main categories:
 * 1. User-Scoped Data: Nested under `/users/{userId}`, this includes private user profiles,
 *    personal order history, and a private management area for a seller's products. Access to
 *    these paths is strictly limited to the authenticated owner.
 * 2. Top-Level Collections: Collections like `/products` and `/orders` serve distinct purposes.
 *    `/products` is a public, read-only collection for all users to browse, with write
 *    permissions restricted to the product's seller. `/orders` and its subcollections are
 *    secured to the customer who created them.
 *
 * Key Security Decisions:
 * - Default Deny: All paths are closed by default. Access is only granted through explicit `allow` rules.
 * - Strict Ownership: A user can only access documents within their own `/users/{userId}` path.
 * - Public Product Discovery: The top-level `/products` collection is publicly readable to allow
 *   all users, including unauthenticated ones, to browse the marketplace.
 * - Seller-Controlled Products: Only the original seller of a product can update or delete it,
 *   enforced via a denormalized `sellerId` field on each product document.
 * - Private Orders: A user can only view their own orders. Access to `/orders/{orderId}` and its
 *   subcollections is controlled by a denormalized `customerId` field on the order document.
 * - No User Listing: It is not possible to list all documents in the `/users` collection,
 *   protecting user privacy.
 *
 * Denormalization for Authorization: To ensure fast and secure access control, authorization
 * data is denormalized. The `/products` collection contains a `sellerId` and the `/orders`
 * collection contains a `customerId`. This avoids slow and costly `get()` calls in rules,
 * making the security model more performant and scalable.
 *
 * Structural Segregation: Private user data and public data are stored in separate collections.
 * For instance, a seller manages their items in the private `/users/{userId}/products` collection,

 * while the public-facing versions reside in the top-level `/products` collection. This prevents
 * accidental data leakage and simplifies rules for list operations.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions to improve readability and reuse of logic.
    function isSignedIn() {
      return request.auth != null;
    }

    // Checks if the requesting user is the owner based on a UID.
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    // Checks for ownership on an existing document. Used for update/delete.
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    // Checks if the requesting user is the owner of a document via a denormalized field.
    function isDocumentOwner(doc) {
      return isSignedIn() && resource != null && request.auth.uid == doc.customerId;
    }

    // Checks if the requesting user is the seller of a product via a denormalized field.
    function isProductSeller(doc) {
      return isSignedIn() && resource != null && request.auth.uid == doc.sellerId;
    }
    
    // Validates that the customerId on a new order matches the creator's UID.
    function isCreatingOwnOrder() {
        return isSignedIn() && request.resource.data.customerId == request.auth.uid;
    }

    // Validates that the sellerId on a new product matches the creator's UID.
    function isCreatingOwnProduct() {
        return isSignedIn() && request.resource.data.sellerId == request.auth.uid;
    }
    
    // Checks if the user associated with a parent order document is the requesting user.
    // This is used to secure access to subcollections like orderItems and payments.
    function isOrderCustomer(orderId) {
      let order = get(/databases/$(database)/documents/orders/$(orderId));
      return isSignedIn() && order.data.customerId == request.auth.uid;
    }

    /**
     * @description Rules for the user's private profile document.
     * @path /users/{userId}
     * @allow (create) A new user signing up: `auth.uid == userId`.
     * @allow (get, update) An existing user accessing their own profile: `auth.uid == userId`.
     * @deny (get) A user trying to read another user's profile.
     * @deny (list) Listing all users in the database is forbidden.
     * @principle Restricts access to a user's own data tree (Self-Creation & Ownership).
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false; // Prevent listing all users
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for a seller's private product management collection.
     * @path /users/{userId}/products/{productId}
     * @allow (create, get, list, update, delete) A seller managing their own products: `auth.uid == userId`.
     * @deny (get) A user trying to view another seller's private product list.
     * @principle Enforces strict ownership within a user's private data subcollections.
     */
    match /users/{userId}/products/{productId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for a user's private order history collection.
     * @path /users/{userId}/orders/{orderId}
     * @allow (create, get, list, update, delete) A customer managing their own orders: `auth.uid == userId`.
     * @deny (get) A user trying to view another user's order history.
     * @principle Enforces strict ownership within a user's private data subcollections.
     */
    match /users/{userId}/orders/{orderId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for the public products collection, visible to everyone.
     * @path /products/{productId}
     * @allow (get, list) Any user, including unauthenticated ones, browsing the marketplace.
     * @allow (create) A signed-in user creating a product where they set themselves as the seller.
     * @allow (update, delete) The seller of the product modifying or deleting their own listing.
     * @deny (update) A user trying to change the price of another seller's product.
     * @principle Implements a Public Read with Owner-Only Writes pattern.
     */
    match /products/{productId} {
      allow get: if true;
      allow list: if true;
      allow create: if isCreatingOwnProduct();
      allow update: if isProductSeller(resource.data);
      allow delete: if isProductSeller(resource.data);
    }

    /**
     * @description Rules for the top-level orders collection.
     * @path /orders/{orderId}
     * @allow (create) A signed-in user creating an order for themselves.
     * @allow (get) The customer who placed the order viewing it.
     * @allow (list) A signed-in user querying for their own orders (requires client-side query constraint).
     * @deny (update, delete) Modifying or deleting placed orders is disallowed for safety.
     * @deny (get) A user trying to view an order placed by someone else.
     * @principle Secures data based on a denormalized `customerId` field.
     */
    match /orders/{orderId} {
      allow get: if isDocumentOwner(resource.data);
      // Allow signed-in users to query the collection.
      // The client MUST use a where('customerId', '==', auth.uid) clause to get results.
      allow list: if isSignedIn();
      allow create: if isCreatingOwnOrder();
      allow update: if false; // Placed orders should not be updatable by the customer.
      allow delete: if false; // Placed orders should not be deletable by the customer.
    }

    /**
     * @description Rules for the items within an order.
     * @path /orders/{orderId}/orderItems/{orderItemId}
     * @allow (get, list, create) The customer who owns the parent order.
     * @deny (update, delete) Order items cannot be changed after the order is placed.
     * @deny (get) A user trying to see the items of an order that is not theirs.
     * @principle Access is derived from the parent document using a `get()` call.
     */
    match /orders/{orderId}/orderItems/{orderItemId} {
      allow get: if isOrderCustomer(orderId);
      allow list: if isOrderCustomer(orderId);
      allow create: if isOrderCustomer(orderId);
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Rules for the payment document associated with an order.
     * @path /orders/{orderId}/payment
     * @allow (get, create) The customer who owns the parent order.
     * @deny (update, delete) Payment information cannot be changed after creation.
     * @deny (get) A user trying to see payment details for another user's order.
     * @principle Access is derived from the parent document using a `get()` call.
     */
    match /orders/{orderId}/payment/{paymentId} { // Assuming paymentId for full path match
      allow get: if isOrderCustomer(orderId);
      allow list: if isOrderCustomer(orderId); // A user can list payments for an order they own
      allow create: if isOrderCustomer(orderId);
      allow update: if false;
      allow delete: if false;
    }
  }
}